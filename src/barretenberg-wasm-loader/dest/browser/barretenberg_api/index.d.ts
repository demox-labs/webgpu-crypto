import { BarretenbergBinder, BarretenbergBinderSync } from '../barretenberg_binder/index.js';
import { Fr, Fq, Point, Buffer32, Buffer128, Ptr } from '../types/index.js';
export declare class BarretenbergApi {
    binder: BarretenbergBinder;
    constructor(binder: BarretenbergBinder);
    destroy(): Promise<void>;
    addFields(left: Fr, right: Fr): Promise<Fr>;
    subFields(left: Fr, right: Fr): Promise<Fr>;
    mulFields(left: Fr, right: Fr): Promise<Fr>;
    invertField(input: Fr): Promise<Fr>;
    expField(base: Fr, exp: Fr): Promise<Fr>;
    sqrtField(base: Fr): Promise<Fr>;
    pedersenInit(): Promise<void>;
    pedersenCompressFields(left: Fr, right: Fr): Promise<Fr>;
    pedersenPlookupCompressFields(left: Fr, right: Fr): Promise<Fr>;
    pedersenCompress(inputsBuffer: Fr[]): Promise<Fr>;
    pedersenPlookupCompress(inputsBuffer: Fr[]): Promise<Fr>;
    pedersenCompressWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Promise<Fr>;
    pedersenCommit(inputsBuffer: Fr[]): Promise<Fr>;
    pedersenPlookupCommit(inputsBuffer: Fr[]): Promise<Fr>;
    pedersenPlookupCommitWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Promise<Fr>;
    pedersenBufferToField(data: Uint8Array): Promise<Fr>;
    pedersenHashInit(): Promise<void>;
    pedersenHashPair(left: Fr, right: Fr): Promise<Fr>;
    pedersenHashMultiple(inputsBuffer: Fr[]): Promise<Fr>;
    pedersenHashMultipleWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Promise<Fr>;
    pedersenHashToTree(data: Fr[]): Promise<Fr[]>;
    blake2s(data: Uint8Array): Promise<Buffer32>;
    blake2sToField(data: Uint8Array): Promise<Fr>;
    schnorrComputePublicKey(privateKey: Fr): Promise<Point>;
    schnorrNegatePublicKey(publicKeyBuffer: Point): Promise<Point>;
    schnorrConstructSignature(message: Uint8Array, privateKey: Fr): Promise<[Buffer32, Buffer32]>;
    schnorrVerifySignature(message: Uint8Array, pubKey: Point, sigS: Buffer32, sigE: Buffer32): Promise<boolean>;
    schnorrMultisigCreateMultisigPublicKey(privateKey: Fq): Promise<Buffer128>;
    schnorrMultisigValidateAndCombineSignerPubkeys(signerPubkeyBuf: Buffer128[]): Promise<[Point, boolean]>;
    schnorrMultisigConstructSignatureRound1(): Promise<[Buffer128, Buffer128]>;
    schnorrMultisigConstructSignatureRound2(message: Uint8Array, privateKey: Fq, signerRoundOnePrivateBuf: Buffer128, signerPubkeysBuf: Buffer128[], roundOnePublicBuf: Buffer128[]): Promise<[Fq, boolean]>;
    schnorrMultisigCombineSignatures(message: Uint8Array, signerPubkeysBuf: Buffer128[], roundOneBuf: Buffer128[], roundTwoBuf: Fr[]): Promise<[Buffer32, Buffer32, boolean]>;
    srsInitSrs(pointsBuf: Uint8Array, numPoints: number, g2PointBuf: Uint8Array): Promise<void>;
    examplesSimpleCreateAndVerifyProof(): Promise<boolean>;
    testThreads(threads: number, iterations: number): Promise<number>;
    testThreadAbort(): Promise<void>;
    testAbort(): Promise<void>;
    commonInitSlabAllocator(circuitSize: number): Promise<void>;
    acirGetCircuitSizes(constraintSystemBuf: Uint8Array): Promise<[number, number, number]>;
    acirNewAcirComposer(sizeHint: number): Promise<Ptr>;
    acirDeleteAcirComposer(acirComposerPtr: Ptr): Promise<void>;
    acirCreateCircuit(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, sizeHint: number): Promise<void>;
    acirInitProvingKey(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array): Promise<void>;
    acirCreateProof(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, witnessBuf: Uint8Array, isRecursive: boolean): Promise<Uint8Array>;
    acirLoadVerificationKey(acirComposerPtr: Ptr, vkBuf: Uint8Array): Promise<void>;
    acirInitVerificationKey(acirComposerPtr: Ptr): Promise<void>;
    acirGetVerificationKey(acirComposerPtr: Ptr): Promise<Uint8Array>;
    acirVerifyProof(acirComposerPtr: Ptr, proofBuf: Uint8Array, isRecursive: boolean): Promise<boolean>;
    acirGetSolidityVerifier(acirComposerPtr: Ptr): Promise<string>;
    acirSerializeProofIntoFields(acirComposerPtr: Ptr, proofBuf: Uint8Array, numInnerPublicInputs: number): Promise<Fr[]>;
    acirSerializeVerificationKeyIntoFields(acirComposerPtr: Ptr): Promise<[Fr[], Fr]>;
}
export declare class BarretenbergApiSync {
    binder: BarretenbergBinderSync;
    constructor(binder: BarretenbergBinderSync);
    destroy(): Promise<void>;
    addFields(left: Fr, right: Fr): Fr;
    subFields(left: Fr, right: Fr): Promise<Fr>;
    mulFields(left: Fr, right: Fr): Promise<Fr>;
    invertField(input: Fr): Promise<Fr>;
    expField(base: Fr, exp: Fr): Promise<Fr>;
    sqrtField(base: Fr): Promise<Fr>;
    pedersenInit(): void;
    pedersenCompressFields(left: Fr, right: Fr): Fr;
    pedersenPlookupCompressFields(left: Fr, right: Fr): Fr;
    pedersenCompress(inputsBuffer: Fr[]): Fr;
    pedersenPlookupCompress(inputsBuffer: Fr[]): Fr;
    pedersenCompressWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Fr;
    pedersenCommit(inputsBuffer: Fr[]): Fr;
    pedersenPlookupCommit(inputsBuffer: Fr[]): Fr;
    pedersenPlookupCommitWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Fr;
    pedersenBufferToField(data: Uint8Array): Fr;
    pedersenHashInit(): void;
    pedersenHashPair(left: Fr, right: Fr): Fr;
    pedersenHashMultiple(inputsBuffer: Fr[]): Fr;
    pedersenHashMultipleWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Fr;
    pedersenHashToTree(data: Fr[]): Fr[];
    blake2s(data: Uint8Array): Buffer32;
    blake2sToField(data: Uint8Array): Fr;
    schnorrComputePublicKey(privateKey: Fr): Point;
    schnorrNegatePublicKey(publicKeyBuffer: Point): Point;
    schnorrConstructSignature(message: Uint8Array, privateKey: Fr): [Buffer32, Buffer32];
    schnorrVerifySignature(message: Uint8Array, pubKey: Point, sigS: Buffer32, sigE: Buffer32): boolean;
    schnorrMultisigCreateMultisigPublicKey(privateKey: Fq): Buffer128;
    schnorrMultisigValidateAndCombineSignerPubkeys(signerPubkeyBuf: Buffer128[]): [Point, boolean];
    schnorrMultisigConstructSignatureRound1(): [Buffer128, Buffer128];
    schnorrMultisigConstructSignatureRound2(message: Uint8Array, privateKey: Fq, signerRoundOnePrivateBuf: Buffer128, signerPubkeysBuf: Buffer128[], roundOnePublicBuf: Buffer128[]): [Fq, boolean];
    schnorrMultisigCombineSignatures(message: Uint8Array, signerPubkeysBuf: Buffer128[], roundOneBuf: Buffer128[], roundTwoBuf: Fr[]): [Buffer32, Buffer32, boolean];
    srsInitSrs(pointsBuf: Uint8Array, numPoints: number, g2PointBuf: Uint8Array): void;
    examplesSimpleCreateAndVerifyProof(): boolean;
    testThreads(threads: number, iterations: number): number;
    testThreadAbort(): void;
    testAbort(): void;
    commonInitSlabAllocator(circuitSize: number): void;
    acirGetCircuitSizes(constraintSystemBuf: Uint8Array): [number, number, number];
    acirNewAcirComposer(sizeHint: number): Ptr;
    acirDeleteAcirComposer(acirComposerPtr: Ptr): void;
    acirCreateCircuit(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, sizeHint: number): void;
    acirInitProvingKey(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array): void;
    acirCreateProof(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, witnessBuf: Uint8Array, isRecursive: boolean): Uint8Array;
    acirLoadVerificationKey(acirComposerPtr: Ptr, vkBuf: Uint8Array): void;
    acirInitVerificationKey(acirComposerPtr: Ptr): void;
    acirGetVerificationKey(acirComposerPtr: Ptr): Uint8Array;
    acirVerifyProof(acirComposerPtr: Ptr, proofBuf: Uint8Array, isRecursive: boolean): boolean;
    acirGetSolidityVerifier(acirComposerPtr: Ptr): string;
    acirSerializeProofIntoFields(acirComposerPtr: Ptr, proofBuf: Uint8Array, numInnerPublicInputs: number): Fr[];
    acirSerializeVerificationKeyIntoFields(acirComposerPtr: Ptr): [Fr[], Fr];
}
//# sourceMappingURL=index.d.ts.map